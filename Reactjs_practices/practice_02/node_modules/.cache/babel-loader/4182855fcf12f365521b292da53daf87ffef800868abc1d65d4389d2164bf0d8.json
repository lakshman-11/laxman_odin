{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar _chalk = _interopRequireDefault(require('chalk'));\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\nvar _constants = require('./constants');\nvar _printDiffs = require('./printDiffs');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst fgDelete = _chalk.default.green;\nconst fgInsert = _chalk.default.red;\nconst fgCommon = _chalk.default.dim; // common lines (even indentation same)\n\nconst fgIndent = _chalk.default.cyan; // common lines (only indentation different)\n\nconst bgCommon = _chalk.default.bgYellow; // edge spaces in common line (even indentation same)\n\nconst bgInverse = _chalk.default.inverse; // edge spaces in any other lines\n// ONLY trailing if expected value is snapshot or multiline string.\n\nconst highlightTrailingSpaces = (line, bgColor) => line.replace(/\\s+$/, bgColor('$&')); // BOTH leading AND trailing if expected value is data structure.\n\nconst highlightLeadingTrailingSpaces = (line, bgColor // If line consists of ALL spaces: highlight all of them.\n) => highlightTrailingSpaces(line, bgColor).replace(\n// If line has an ODD length of leading spaces: highlight only the LAST.\n/^(\\s\\s)*(\\s)(?=[^\\s])/, '$1' + bgColor('$2'));\nconst getHighlightSpaces = bothEdges => bothEdges ? highlightLeadingTrailingSpaces : highlightTrailingSpaces;\n\n// Given index interval in expected lines, put formatted delete lines.\nconst formatDelete = (aStart, aEnd, aLinesUn, aLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(aLinesUn !== aLinesIn);\n  for (let aIndex = aStart; aIndex !== aEnd; aIndex += 1) {\n    const aLineUn = aLinesUn[aIndex];\n    const aLineIn = aLinesIn[aIndex];\n    const indentation = aLineIn.slice(0, aLineIn.length - aLineUn.length);\n    put(fgDelete('- ' + indentation + highlightSpaces(aLineUn, bgInverse)));\n  }\n}; // Given index interval in received lines, put formatted insert lines.\n\nconst formatInsert = (bStart, bEnd, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n  for (let bIndex = bStart; bIndex !== bEnd; bIndex += 1) {\n    const bLineUn = bLinesUn[bIndex];\n    const bLineIn = bLinesIn[bIndex];\n    const indentation = bLineIn.slice(0, bLineIn.length - bLineUn.length);\n    put(fgInsert('+ ' + indentation + highlightSpaces(bLineUn, bgInverse)));\n  }\n}; // Given the number of items and starting indexes of a common subsequence,\n// put formatted common lines.\n\nconst formatCommon = (nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n  for (; nCommon !== 0; nCommon -= 1, aCommon += 1, bCommon += 1) {\n    const bLineUn = bLinesUn[bCommon];\n    const bLineIn = bLinesIn[bCommon];\n    const bLineInLength = bLineIn.length; // For common lines, received indentation seems more intuitive.\n\n    const indentation = bLineIn.slice(0, bLineInLength - bLineUn.length); // Color shows whether expected and received line has same indentation.\n\n    const hasSameIndentation = aLinesIn[aCommon].length === bLineInLength;\n    const fg = hasSameIndentation ? fgCommon : fgIndent;\n    const bg = hasSameIndentation ? bgCommon : bgInverse;\n    put(fg('  ' + indentation + highlightSpaces(bLineUn, bg)));\n  }\n}; // jest --expand\n// Return formatted diff as joined string of all lines.\n\nconst diffExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n  const array = [];\n  const put = line => {\n    array.push(line);\n  };\n  let aStart = 0;\n  let bStart = 0;\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    formatDelete(aStart, aCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bStart, bCommon, bLinesUn, bLinesIn, put);\n    formatCommon(nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put);\n    aStart = aCommon + nCommon;\n    bStart = bCommon + nCommon;\n  };\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, format remaining change lines.\n\n  formatDelete(aStart, aLength, aLinesUn, aLinesIn, put);\n  formatInsert(bStart, bLength, bLinesUn, bLinesIn, put);\n  return array.join('\\n');\n};\nconst getContextLines = options => options && typeof options.contextLines === 'number' && options.contextLines >= 0 ? options.contextLines : DIFF_CONTEXT_DEFAULT; // jest --no-expand\n// Return joined string of formatted diff for all change lines,\n// but if some common lines are omitted because there are more than the context,\n// then a “patch mark” precedes each set of adjacent changed and common lines.\n\nconst diffNoExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn, nContextLines) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n  let iPatchMark = 0; // index of placeholder line for patch mark\n\n  const array = [''];\n  const put = line => {\n    array.push(line);\n  };\n  let isAtEnd = false;\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  const nContextLines2 = nContextLines + nContextLines; // Initialize the first patch for changes at the start,\n  // especially for edge case in which there is no common subsequence.\n\n  let aStart = 0;\n  let aEnd = 0;\n  let bStart = 0;\n  let bEnd = 0; // Given the number of items and starting indexes of each common subsequence,\n  // format any preceding change lines, and then common context lines.\n\n  const foundSubsequence = (nCommon, aStartCommon, bStartCommon) => {\n    const aEndCommon = aStartCommon + nCommon;\n    const bEndCommon = bStartCommon + nCommon;\n    isAtEnd = aEndCommon === aLength && bEndCommon === bLength; // If common subsequence is at start, re-initialize the first patch.\n\n    if (aStartCommon === 0 && bStartCommon === 0) {\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n      return;\n    } // Format preceding change lines.\n\n    formatDelete(aEnd, aStartCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bStartCommon, bLinesUn, bLinesIn, put);\n    aEnd = aStartCommon;\n    bEnd = bStartCommon; // If common subsequence is at end, then context follows preceding changes;\n    // else context follows preceding changes AND precedes following changes.\n\n    const maxContextLines = isAtEnd ? nContextLines : nContextLines2;\n    if (nCommon <= maxContextLines) {\n      // The patch includes all lines in the common subsequence.\n      formatCommon(nCommon, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd += nCommon;\n      bEnd += nCommon;\n      return;\n    } // The patch ends because context is less than number of common lines.\n\n    formatCommon(nContextLines, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n    aEnd += nContextLines;\n    bEnd += nContextLines;\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(aStart, aEnd, bStart, bEnd); // If common subsequence is not at end, another patch follows it.\n\n    if (!isAtEnd) {\n      iPatchMark = array.length; // index of placeholder line\n\n      array[iPatchMark] = '';\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n    }\n  };\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // If no common subsequence or last was not at end, format remaining change lines.\n\n  if (!isAtEnd) {\n    formatDelete(aEnd, aLength, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bLength, bLinesUn, bLinesIn, put);\n    aEnd = aLength;\n    bEnd = bLength;\n  }\n  if (aStart === 0 && aEnd === aLength && bStart === 0 && bEnd === bLength) {\n    array.splice(0, 1); // delete placeholder line for patch mark\n  } else {\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(aStart, aEnd, bStart, bEnd);\n  }\n  return array.join('\\n');\n};\nvar _default = (a, b, options, original) => {\n  if (a === b) {\n    return _constants.NO_DIFF_MESSAGE;\n  }\n  let aLinesUn = a.split('\\n');\n  let bLinesUn = b.split('\\n'); // Indentation is unknown if expected value is snapshot or multiline string.\n\n  let aLinesIn = aLinesUn;\n  let bLinesIn = bLinesUn;\n  if (original) {\n    // Indentation is known if expected value is data structure:\n    // Compare lines without indentation and format lines with indentation.\n    aLinesIn = original.a.split('\\n');\n    bLinesIn = original.b.split('\\n');\n    if (aLinesUn.length !== aLinesIn.length || bLinesUn.length !== bLinesIn.length) {\n      // Fall back if unindented and indented lines are inconsistent.\n      aLinesUn = aLinesIn;\n      bLinesUn = bLinesIn;\n    }\n  }\n  return (0, _printDiffs.printAnnotation)(options) + (options && options.expand === false ? diffNoExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn, getContextLines(options)) : diffExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn));\n};\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_chalk","_interopRequireDefault","require","_diffSequences","_constants","_printDiffs","obj","__esModule","DIFF_CONTEXT_DEFAULT","fgDelete","green","fgInsert","red","fgCommon","dim","fgIndent","cyan","bgCommon","bgYellow","bgInverse","inverse","highlightTrailingSpaces","line","bgColor","replace","highlightLeadingTrailingSpaces","getHighlightSpaces","bothEdges","formatDelete","aStart","aEnd","aLinesUn","aLinesIn","put","highlightSpaces","aIndex","aLineUn","aLineIn","indentation","slice","length","formatInsert","bStart","bEnd","bLinesUn","bLinesIn","bIndex","bLineUn","bLineIn","formatCommon","nCommon","aCommon","bCommon","bLineInLength","hasSameIndentation","fg","bg","diffExpand","isCommon","array","push","foundSubsequence","aLength","bLength","join","getContextLines","options","contextLines","diffNoExpand","nContextLines","iPatchMark","isAtEnd","nContextLines2","aStartCommon","bStartCommon","aEndCommon","bEndCommon","nLines","maxContextLines","createPatchMark","splice","_default","a","b","original","NO_DIFF_MESSAGE","split","printAnnotation","expand"],"sources":["/home/laxus/Uchiha/[GigaCourse.Com] Udemy - React - The Complete Guide (incl Hooks, React Router, Redux)/08 - Time to Practice_ A Complete Practice Project/01-starting-project/node_modules/jest-diff/build/diffLines.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _constants = require('./constants');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst fgDelete = _chalk.default.green;\nconst fgInsert = _chalk.default.red;\nconst fgCommon = _chalk.default.dim; // common lines (even indentation same)\n\nconst fgIndent = _chalk.default.cyan; // common lines (only indentation different)\n\nconst bgCommon = _chalk.default.bgYellow; // edge spaces in common line (even indentation same)\n\nconst bgInverse = _chalk.default.inverse; // edge spaces in any other lines\n// ONLY trailing if expected value is snapshot or multiline string.\n\nconst highlightTrailingSpaces = (line, bgColor) =>\n  line.replace(/\\s+$/, bgColor('$&')); // BOTH leading AND trailing if expected value is data structure.\n\nconst highlightLeadingTrailingSpaces = (\n  line,\n  bgColor // If line consists of ALL spaces: highlight all of them.\n) =>\n  highlightTrailingSpaces(line, bgColor).replace(\n    // If line has an ODD length of leading spaces: highlight only the LAST.\n    /^(\\s\\s)*(\\s)(?=[^\\s])/,\n    '$1' + bgColor('$2')\n  );\n\nconst getHighlightSpaces = bothEdges =>\n  bothEdges ? highlightLeadingTrailingSpaces : highlightTrailingSpaces;\n\n// Given index interval in expected lines, put formatted delete lines.\nconst formatDelete = (aStart, aEnd, aLinesUn, aLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(aLinesUn !== aLinesIn);\n\n  for (let aIndex = aStart; aIndex !== aEnd; aIndex += 1) {\n    const aLineUn = aLinesUn[aIndex];\n    const aLineIn = aLinesIn[aIndex];\n    const indentation = aLineIn.slice(0, aLineIn.length - aLineUn.length);\n    put(fgDelete('- ' + indentation + highlightSpaces(aLineUn, bgInverse)));\n  }\n}; // Given index interval in received lines, put formatted insert lines.\n\nconst formatInsert = (bStart, bEnd, bLinesUn, bLinesIn, put) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (let bIndex = bStart; bIndex !== bEnd; bIndex += 1) {\n    const bLineUn = bLinesUn[bIndex];\n    const bLineIn = bLinesIn[bIndex];\n    const indentation = bLineIn.slice(0, bLineIn.length - bLineUn.length);\n    put(fgInsert('+ ' + indentation + highlightSpaces(bLineUn, bgInverse)));\n  }\n}; // Given the number of items and starting indexes of a common subsequence,\n// put formatted common lines.\n\nconst formatCommon = (\n  nCommon,\n  aCommon,\n  bCommon,\n  aLinesIn,\n  bLinesUn,\n  bLinesIn,\n  put\n) => {\n  const highlightSpaces = getHighlightSpaces(bLinesUn !== bLinesIn);\n\n  for (; nCommon !== 0; nCommon -= 1, aCommon += 1, bCommon += 1) {\n    const bLineUn = bLinesUn[bCommon];\n    const bLineIn = bLinesIn[bCommon];\n    const bLineInLength = bLineIn.length; // For common lines, received indentation seems more intuitive.\n\n    const indentation = bLineIn.slice(0, bLineInLength - bLineUn.length); // Color shows whether expected and received line has same indentation.\n\n    const hasSameIndentation = aLinesIn[aCommon].length === bLineInLength;\n    const fg = hasSameIndentation ? fgCommon : fgIndent;\n    const bg = hasSameIndentation ? bgCommon : bgInverse;\n    put(fg('  ' + indentation + highlightSpaces(bLineUn, bg)));\n  }\n}; // jest --expand\n// Return formatted diff as joined string of all lines.\n\nconst diffExpand = (aLinesUn, bLinesUn, aLinesIn, bLinesIn) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  const array = [];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let aStart = 0;\n  let bStart = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    formatDelete(aStart, aCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bStart, bCommon, bLinesUn, bLinesIn, put);\n    formatCommon(nCommon, aCommon, bCommon, aLinesIn, bLinesUn, bLinesIn, put);\n    aStart = aCommon + nCommon;\n    bStart = bCommon + nCommon;\n  };\n\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, format remaining change lines.\n\n  formatDelete(aStart, aLength, aLinesUn, aLinesIn, put);\n  formatInsert(bStart, bLength, bLinesUn, bLinesIn, put);\n  return array.join('\\n');\n};\n\nconst getContextLines = options =>\n  options &&\n  typeof options.contextLines === 'number' &&\n  options.contextLines >= 0\n    ? options.contextLines\n    : DIFF_CONTEXT_DEFAULT; // jest --no-expand\n// Return joined string of formatted diff for all change lines,\n// but if some common lines are omitted because there are more than the context,\n// then a “patch mark” precedes each set of adjacent changed and common lines.\n\nconst diffNoExpand = (\n  aLinesUn,\n  bLinesUn,\n  aLinesIn,\n  bLinesIn,\n  nContextLines\n) => {\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  let iPatchMark = 0; // index of placeholder line for patch mark\n\n  const array = [''];\n\n  const put = line => {\n    array.push(line);\n  };\n\n  let isAtEnd = false;\n  const aLength = aLinesUn.length;\n  const bLength = bLinesUn.length;\n  const nContextLines2 = nContextLines + nContextLines; // Initialize the first patch for changes at the start,\n  // especially for edge case in which there is no common subsequence.\n\n  let aStart = 0;\n  let aEnd = 0;\n  let bStart = 0;\n  let bEnd = 0; // Given the number of items and starting indexes of each common subsequence,\n  // format any preceding change lines, and then common context lines.\n\n  const foundSubsequence = (nCommon, aStartCommon, bStartCommon) => {\n    const aEndCommon = aStartCommon + nCommon;\n    const bEndCommon = bStartCommon + nCommon;\n    isAtEnd = aEndCommon === aLength && bEndCommon === bLength; // If common subsequence is at start, re-initialize the first patch.\n\n    if (aStartCommon === 0 && bStartCommon === 0) {\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n      return;\n    } // Format preceding change lines.\n\n    formatDelete(aEnd, aStartCommon, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bStartCommon, bLinesUn, bLinesIn, put);\n    aEnd = aStartCommon;\n    bEnd = bStartCommon; // If common subsequence is at end, then context follows preceding changes;\n    // else context follows preceding changes AND precedes following changes.\n\n    const maxContextLines = isAtEnd ? nContextLines : nContextLines2;\n\n    if (nCommon <= maxContextLines) {\n      // The patch includes all lines in the common subsequence.\n      formatCommon(nCommon, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd += nCommon;\n      bEnd += nCommon;\n      return;\n    } // The patch ends because context is less than number of common lines.\n\n    formatCommon(nContextLines, aEnd, bEnd, aLinesIn, bLinesUn, bLinesIn, put);\n    aEnd += nContextLines;\n    bEnd += nContextLines;\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(\n      aStart,\n      aEnd,\n      bStart,\n      bEnd\n    ); // If common subsequence is not at end, another patch follows it.\n\n    if (!isAtEnd) {\n      iPatchMark = array.length; // index of placeholder line\n\n      array[iPatchMark] = '';\n      const nLines = nContextLines < nCommon ? nContextLines : nCommon;\n      aStart = aEndCommon - nLines;\n      bStart = bEndCommon - nLines;\n      formatCommon(nLines, aStart, bStart, aLinesIn, bLinesUn, bLinesIn, put);\n      aEnd = aEndCommon;\n      bEnd = bEndCommon;\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // If no common subsequence or last was not at end, format remaining change lines.\n\n  if (!isAtEnd) {\n    formatDelete(aEnd, aLength, aLinesUn, aLinesIn, put);\n    formatInsert(bEnd, bLength, bLinesUn, bLinesIn, put);\n    aEnd = aLength;\n    bEnd = bLength;\n  }\n\n  if (aStart === 0 && aEnd === aLength && bStart === 0 && bEnd === bLength) {\n    array.splice(0, 1); // delete placeholder line for patch mark\n  } else {\n    array[iPatchMark] = (0, _printDiffs.createPatchMark)(\n      aStart,\n      aEnd,\n      bStart,\n      bEnd\n    );\n  }\n\n  return array.join('\\n');\n};\n\nvar _default = (a, b, options, original) => {\n  if (a === b) {\n    return _constants.NO_DIFF_MESSAGE;\n  }\n\n  let aLinesUn = a.split('\\n');\n  let bLinesUn = b.split('\\n'); // Indentation is unknown if expected value is snapshot or multiline string.\n\n  let aLinesIn = aLinesUn;\n  let bLinesIn = bLinesUn;\n\n  if (original) {\n    // Indentation is known if expected value is data structure:\n    // Compare lines without indentation and format lines with indentation.\n    aLinesIn = original.a.split('\\n');\n    bLinesIn = original.b.split('\\n');\n\n    if (\n      aLinesUn.length !== aLinesIn.length ||\n      bLinesUn.length !== bLinesIn.length\n    ) {\n      // Fall back if unindented and indented lines are inconsistent.\n      aLinesUn = aLinesIn;\n      bLinesUn = bLinesIn;\n    }\n  }\n\n  return (\n    (0, _printDiffs.printAnnotation)(options) +\n    (options && options.expand === false\n      ? diffNoExpand(\n          aLinesUn,\n          bLinesUn,\n          aLinesIn,\n          bLinesIn,\n          getContextLines(options)\n        )\n      : diffExpand(aLinesUn, bLinesUn, aLinesIn, bLinesIn))\n  );\n};\n\nexports.default = _default;\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AAExB,IAAIC,MAAM,GAAGC,sBAAsB,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC;AAErD,IAAIC,cAAc,GAAGF,sBAAsB,CAACC,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAEtE,IAAIE,UAAU,GAAGF,OAAO,CAAC,aAAa,CAAC;AAEvC,IAAIG,WAAW,GAAGH,OAAO,CAAC,cAAc,CAAC;AAEzC,SAASD,sBAAsB,CAACK,GAAG,EAAE;EACnC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAACP,OAAO,EAAEO;EAAG,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,oBAAoB,GAAG,CAAC;AAC9B,MAAMC,QAAQ,GAAGT,MAAM,CAACD,OAAO,CAACW,KAAK;AACrC,MAAMC,QAAQ,GAAGX,MAAM,CAACD,OAAO,CAACa,GAAG;AACnC,MAAMC,QAAQ,GAAGb,MAAM,CAACD,OAAO,CAACe,GAAG,CAAC,CAAC;;AAErC,MAAMC,QAAQ,GAAGf,MAAM,CAACD,OAAO,CAACiB,IAAI,CAAC,CAAC;;AAEtC,MAAMC,QAAQ,GAAGjB,MAAM,CAACD,OAAO,CAACmB,QAAQ,CAAC,CAAC;;AAE1C,MAAMC,SAAS,GAAGnB,MAAM,CAACD,OAAO,CAACqB,OAAO,CAAC,CAAC;AAC1C;;AAEA,MAAMC,uBAAuB,GAAG,CAACC,IAAI,EAAEC,OAAO,KAC5CD,IAAI,CAACE,OAAO,CAAC,MAAM,EAAED,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;AAEvC,MAAME,8BAA8B,GAAG,CACrCH,IAAI,EACJC,OAAO,CAAC;AAAA,KAERF,uBAAuB,CAACC,IAAI,EAAEC,OAAO,CAAC,CAACC,OAAO;AAC5C;AACA,uBAAuB,EACvB,IAAI,GAAGD,OAAO,CAAC,IAAI,CAAC,CACrB;AAEH,MAAMG,kBAAkB,GAAGC,SAAS,IAClCA,SAAS,GAAGF,8BAA8B,GAAGJ,uBAAuB;;AAEtE;AACA,MAAMO,YAAY,GAAG,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,KAAK;EAC9D,MAAMC,eAAe,GAAGR,kBAAkB,CAACK,QAAQ,KAAKC,QAAQ,CAAC;EAEjE,KAAK,IAAIG,MAAM,GAAGN,MAAM,EAAEM,MAAM,KAAKL,IAAI,EAAEK,MAAM,IAAI,CAAC,EAAE;IACtD,MAAMC,OAAO,GAAGL,QAAQ,CAACI,MAAM,CAAC;IAChC,MAAME,OAAO,GAAGL,QAAQ,CAACG,MAAM,CAAC;IAChC,MAAMG,WAAW,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC,EAAEF,OAAO,CAACG,MAAM,GAAGJ,OAAO,CAACI,MAAM,CAAC;IACrEP,GAAG,CAACxB,QAAQ,CAAC,IAAI,GAAG6B,WAAW,GAAGJ,eAAe,CAACE,OAAO,EAAEjB,SAAS,CAAC,CAAC,CAAC;EACzE;AACF,CAAC,CAAC,CAAC;;AAEH,MAAMsB,YAAY,GAAG,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,KAAK;EAC9D,MAAMC,eAAe,GAAGR,kBAAkB,CAACkB,QAAQ,KAAKC,QAAQ,CAAC;EAEjE,KAAK,IAAIC,MAAM,GAAGJ,MAAM,EAAEI,MAAM,KAAKH,IAAI,EAAEG,MAAM,IAAI,CAAC,EAAE;IACtD,MAAMC,OAAO,GAAGH,QAAQ,CAACE,MAAM,CAAC;IAChC,MAAME,OAAO,GAAGH,QAAQ,CAACC,MAAM,CAAC;IAChC,MAAMR,WAAW,GAAGU,OAAO,CAACT,KAAK,CAAC,CAAC,EAAES,OAAO,CAACR,MAAM,GAAGO,OAAO,CAACP,MAAM,CAAC;IACrEP,GAAG,CAACtB,QAAQ,CAAC,IAAI,GAAG2B,WAAW,GAAGJ,eAAe,CAACa,OAAO,EAAE5B,SAAS,CAAC,CAAC,CAAC;EACzE;AACF,CAAC,CAAC,CAAC;AACH;;AAEA,MAAM8B,YAAY,GAAG,CACnBC,OAAO,EACPC,OAAO,EACPC,OAAO,EACPpB,QAAQ,EACRY,QAAQ,EACRC,QAAQ,EACRZ,GAAG,KACA;EACH,MAAMC,eAAe,GAAGR,kBAAkB,CAACkB,QAAQ,KAAKC,QAAQ,CAAC;EAEjE,OAAOK,OAAO,KAAK,CAAC,EAAEA,OAAO,IAAI,CAAC,EAAEC,OAAO,IAAI,CAAC,EAAEC,OAAO,IAAI,CAAC,EAAE;IAC9D,MAAML,OAAO,GAAGH,QAAQ,CAACQ,OAAO,CAAC;IACjC,MAAMJ,OAAO,GAAGH,QAAQ,CAACO,OAAO,CAAC;IACjC,MAAMC,aAAa,GAAGL,OAAO,CAACR,MAAM,CAAC,CAAC;;IAEtC,MAAMF,WAAW,GAAGU,OAAO,CAACT,KAAK,CAAC,CAAC,EAAEc,aAAa,GAAGN,OAAO,CAACP,MAAM,CAAC,CAAC,CAAC;;IAEtE,MAAMc,kBAAkB,GAAGtB,QAAQ,CAACmB,OAAO,CAAC,CAACX,MAAM,KAAKa,aAAa;IACrE,MAAME,EAAE,GAAGD,kBAAkB,GAAGzC,QAAQ,GAAGE,QAAQ;IACnD,MAAMyC,EAAE,GAAGF,kBAAkB,GAAGrC,QAAQ,GAAGE,SAAS;IACpDc,GAAG,CAACsB,EAAE,CAAC,IAAI,GAAGjB,WAAW,GAAGJ,eAAe,CAACa,OAAO,EAAES,EAAE,CAAC,CAAC,CAAC;EAC5D;AACF,CAAC,CAAC,CAAC;AACH;;AAEA,MAAMC,UAAU,GAAG,CAAC1B,QAAQ,EAAEa,QAAQ,EAAEZ,QAAQ,EAAEa,QAAQ,KAAK;EAC7D,MAAMa,QAAQ,GAAG,CAACvB,MAAM,EAAEW,MAAM,KAAKf,QAAQ,CAACI,MAAM,CAAC,KAAKS,QAAQ,CAACE,MAAM,CAAC;EAE1E,MAAMa,KAAK,GAAG,EAAE;EAEhB,MAAM1B,GAAG,GAAGX,IAAI,IAAI;IAClBqC,KAAK,CAACC,IAAI,CAACtC,IAAI,CAAC;EAClB,CAAC;EAED,IAAIO,MAAM,GAAG,CAAC;EACd,IAAIa,MAAM,GAAG,CAAC;EAEd,MAAMmB,gBAAgB,GAAG,CAACX,OAAO,EAAEC,OAAO,EAAEC,OAAO,KAAK;IACtDxB,YAAY,CAACC,MAAM,EAAEsB,OAAO,EAAEpB,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,CAAC;IACtDQ,YAAY,CAACC,MAAM,EAAEU,OAAO,EAAER,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;IACtDgB,YAAY,CAACC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEpB,QAAQ,EAAEY,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;IAC1EJ,MAAM,GAAGsB,OAAO,GAAGD,OAAO;IAC1BR,MAAM,GAAGU,OAAO,GAAGF,OAAO;EAC5B,CAAC;EAED,MAAMY,OAAO,GAAG/B,QAAQ,CAACS,MAAM;EAC/B,MAAMuB,OAAO,GAAGnB,QAAQ,CAACJ,MAAM;EAC/B,CAAC,CAAC,EAAErC,cAAc,CAACJ,OAAO,EAAE+D,OAAO,EAAEC,OAAO,EAAEL,QAAQ,EAAEG,gBAAgB,CAAC,CAAC,CAAC;;EAE3EjC,YAAY,CAACC,MAAM,EAAEiC,OAAO,EAAE/B,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,CAAC;EACtDQ,YAAY,CAACC,MAAM,EAAEqB,OAAO,EAAEnB,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;EACtD,OAAO0B,KAAK,CAACK,IAAI,CAAC,IAAI,CAAC;AACzB,CAAC;AAED,MAAMC,eAAe,GAAGC,OAAO,IAC7BA,OAAO,IACP,OAAOA,OAAO,CAACC,YAAY,KAAK,QAAQ,IACxCD,OAAO,CAACC,YAAY,IAAI,CAAC,GACrBD,OAAO,CAACC,YAAY,GACpB3D,oBAAoB,CAAC,CAAC;AAC5B;AACA;AACA;;AAEA,MAAM4D,YAAY,GAAG,CACnBrC,QAAQ,EACRa,QAAQ,EACRZ,QAAQ,EACRa,QAAQ,EACRwB,aAAa,KACV;EACH,MAAMX,QAAQ,GAAG,CAACvB,MAAM,EAAEW,MAAM,KAAKf,QAAQ,CAACI,MAAM,CAAC,KAAKS,QAAQ,CAACE,MAAM,CAAC;EAE1E,IAAIwB,UAAU,GAAG,CAAC,CAAC,CAAC;;EAEpB,MAAMX,KAAK,GAAG,CAAC,EAAE,CAAC;EAElB,MAAM1B,GAAG,GAAGX,IAAI,IAAI;IAClBqC,KAAK,CAACC,IAAI,CAACtC,IAAI,CAAC;EAClB,CAAC;EAED,IAAIiD,OAAO,GAAG,KAAK;EACnB,MAAMT,OAAO,GAAG/B,QAAQ,CAACS,MAAM;EAC/B,MAAMuB,OAAO,GAAGnB,QAAQ,CAACJ,MAAM;EAC/B,MAAMgC,cAAc,GAAGH,aAAa,GAAGA,aAAa,CAAC,CAAC;EACtD;;EAEA,IAAIxC,MAAM,GAAG,CAAC;EACd,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIY,MAAM,GAAG,CAAC;EACd,IAAIC,IAAI,GAAG,CAAC,CAAC,CAAC;EACd;;EAEA,MAAMkB,gBAAgB,GAAG,CAACX,OAAO,EAAEuB,YAAY,EAAEC,YAAY,KAAK;IAChE,MAAMC,UAAU,GAAGF,YAAY,GAAGvB,OAAO;IACzC,MAAM0B,UAAU,GAAGF,YAAY,GAAGxB,OAAO;IACzCqB,OAAO,GAAGI,UAAU,KAAKb,OAAO,IAAIc,UAAU,KAAKb,OAAO,CAAC,CAAC;;IAE5D,IAAIU,YAAY,KAAK,CAAC,IAAIC,YAAY,KAAK,CAAC,EAAE;MAC5C,MAAMG,MAAM,GAAGR,aAAa,GAAGnB,OAAO,GAAGmB,aAAa,GAAGnB,OAAO;MAChErB,MAAM,GAAG8C,UAAU,GAAGE,MAAM;MAC5BnC,MAAM,GAAGkC,UAAU,GAAGC,MAAM;MAC5B5B,YAAY,CAAC4B,MAAM,EAAEhD,MAAM,EAAEa,MAAM,EAAEV,QAAQ,EAAEY,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;MACvEH,IAAI,GAAG6C,UAAU;MACjBhC,IAAI,GAAGiC,UAAU;MACjB;IACF,CAAC,CAAC;;IAEFhD,YAAY,CAACE,IAAI,EAAE2C,YAAY,EAAE1C,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,CAAC;IACzDQ,YAAY,CAACE,IAAI,EAAE+B,YAAY,EAAE9B,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;IACzDH,IAAI,GAAG2C,YAAY;IACnB9B,IAAI,GAAG+B,YAAY,CAAC,CAAC;IACrB;;IAEA,MAAMI,eAAe,GAAGP,OAAO,GAAGF,aAAa,GAAGG,cAAc;IAEhE,IAAItB,OAAO,IAAI4B,eAAe,EAAE;MAC9B;MACA7B,YAAY,CAACC,OAAO,EAAEpB,IAAI,EAAEa,IAAI,EAAEX,QAAQ,EAAEY,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;MACpEH,IAAI,IAAIoB,OAAO;MACfP,IAAI,IAAIO,OAAO;MACf;IACF,CAAC,CAAC;;IAEFD,YAAY,CAACoB,aAAa,EAAEvC,IAAI,EAAEa,IAAI,EAAEX,QAAQ,EAAEY,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;IAC1EH,IAAI,IAAIuC,aAAa;IACrB1B,IAAI,IAAI0B,aAAa;IACrBV,KAAK,CAACW,UAAU,CAAC,GAAG,CAAC,CAAC,EAAEjE,WAAW,CAAC0E,eAAe,EACjDlD,MAAM,EACNC,IAAI,EACJY,MAAM,EACNC,IAAI,CACL,CAAC,CAAC;;IAEH,IAAI,CAAC4B,OAAO,EAAE;MACZD,UAAU,GAAGX,KAAK,CAACnB,MAAM,CAAC,CAAC;;MAE3BmB,KAAK,CAACW,UAAU,CAAC,GAAG,EAAE;MACtB,MAAMO,MAAM,GAAGR,aAAa,GAAGnB,OAAO,GAAGmB,aAAa,GAAGnB,OAAO;MAChErB,MAAM,GAAG8C,UAAU,GAAGE,MAAM;MAC5BnC,MAAM,GAAGkC,UAAU,GAAGC,MAAM;MAC5B5B,YAAY,CAAC4B,MAAM,EAAEhD,MAAM,EAAEa,MAAM,EAAEV,QAAQ,EAAEY,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;MACvEH,IAAI,GAAG6C,UAAU;MACjBhC,IAAI,GAAGiC,UAAU;IACnB;EACF,CAAC;EAED,CAAC,CAAC,EAAEzE,cAAc,CAACJ,OAAO,EAAE+D,OAAO,EAAEC,OAAO,EAAEL,QAAQ,EAAEG,gBAAgB,CAAC,CAAC,CAAC;;EAE3E,IAAI,CAACU,OAAO,EAAE;IACZ3C,YAAY,CAACE,IAAI,EAAEgC,OAAO,EAAE/B,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,CAAC;IACpDQ,YAAY,CAACE,IAAI,EAAEoB,OAAO,EAAEnB,QAAQ,EAAEC,QAAQ,EAAEZ,GAAG,CAAC;IACpDH,IAAI,GAAGgC,OAAO;IACdnB,IAAI,GAAGoB,OAAO;EAChB;EAEA,IAAIlC,MAAM,KAAK,CAAC,IAAIC,IAAI,KAAKgC,OAAO,IAAIpB,MAAM,KAAK,CAAC,IAAIC,IAAI,KAAKoB,OAAO,EAAE;IACxEJ,KAAK,CAACqB,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACtB,CAAC,MAAM;IACLrB,KAAK,CAACW,UAAU,CAAC,GAAG,CAAC,CAAC,EAAEjE,WAAW,CAAC0E,eAAe,EACjDlD,MAAM,EACNC,IAAI,EACJY,MAAM,EACNC,IAAI,CACL;EACH;EAEA,OAAOgB,KAAK,CAACK,IAAI,CAAC,IAAI,CAAC;AACzB,CAAC;AAED,IAAIiB,QAAQ,GAAG,CAACC,CAAC,EAAEC,CAAC,EAAEjB,OAAO,EAAEkB,QAAQ,KAAK;EAC1C,IAAIF,CAAC,KAAKC,CAAC,EAAE;IACX,OAAO/E,UAAU,CAACiF,eAAe;EACnC;EAEA,IAAItD,QAAQ,GAAGmD,CAAC,CAACI,KAAK,CAAC,IAAI,CAAC;EAC5B,IAAI1C,QAAQ,GAAGuC,CAAC,CAACG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;;EAE9B,IAAItD,QAAQ,GAAGD,QAAQ;EACvB,IAAIc,QAAQ,GAAGD,QAAQ;EAEvB,IAAIwC,QAAQ,EAAE;IACZ;IACA;IACApD,QAAQ,GAAGoD,QAAQ,CAACF,CAAC,CAACI,KAAK,CAAC,IAAI,CAAC;IACjCzC,QAAQ,GAAGuC,QAAQ,CAACD,CAAC,CAACG,KAAK,CAAC,IAAI,CAAC;IAEjC,IACEvD,QAAQ,CAACS,MAAM,KAAKR,QAAQ,CAACQ,MAAM,IACnCI,QAAQ,CAACJ,MAAM,KAAKK,QAAQ,CAACL,MAAM,EACnC;MACA;MACAT,QAAQ,GAAGC,QAAQ;MACnBY,QAAQ,GAAGC,QAAQ;IACrB;EACF;EAEA,OACE,CAAC,CAAC,EAAExC,WAAW,CAACkF,eAAe,EAAErB,OAAO,CAAC,IACxCA,OAAO,IAAIA,OAAO,CAACsB,MAAM,KAAK,KAAK,GAChCpB,YAAY,CACVrC,QAAQ,EACRa,QAAQ,EACRZ,QAAQ,EACRa,QAAQ,EACRoB,eAAe,CAACC,OAAO,CAAC,CACzB,GACDT,UAAU,CAAC1B,QAAQ,EAAEa,QAAQ,EAAEZ,QAAQ,EAAEa,QAAQ,CAAC,CAAC;AAE3D,CAAC;AAEDhD,OAAO,CAACE,OAAO,GAAGkF,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}