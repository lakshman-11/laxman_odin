{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getStringDiff = exports.printMultilineStringDiffs = exports.createPatchMark = exports.printAnnotation = exports.hasCommonDiff = exports.computeStringDiffs = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = exports.MULTILINE_REGEXP = exports.getReceivedString = exports.getExpectedString = exports.getHighlightedString = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = void 0;\nvar _chalk = _interopRequireDefault(require('chalk'));\nvar _cleanupSemantic = require('./cleanupSemantic');\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIM_COLOR = _chalk.default.dim;\nexports.DIM_COLOR = DIM_COLOR;\nconst EXPECTED_COLOR = _chalk.default.green;\nexports.EXPECTED_COLOR = EXPECTED_COLOR;\nconst INVERTED_COLOR = _chalk.default.inverse;\nexports.INVERTED_COLOR = INVERTED_COLOR;\nconst RECEIVED_COLOR = _chalk.default.red;\nexports.RECEIVED_COLOR = RECEIVED_COLOR;\nconst PATCH_COLOR = _chalk.default.yellow; // Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op (inverse highlight)\n// * exclude change strings which have opposite op\n\nconst getHighlightedString = (op, diffs) => diffs.reduce((reduced, diff) => reduced + (diff[0] === _cleanupSemantic.DIFF_EQUAL ? diff[1] : diff[0] === op ? INVERTED_COLOR(diff[1]) : ''), '');\nexports.getHighlightedString = getHighlightedString;\nconst getExpectedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_DELETE, diffs);\nexports.getExpectedString = getExpectedString;\nconst getReceivedString = diffs => getHighlightedString(_cleanupSemantic.DIFF_INSERT, diffs);\nexports.getReceivedString = getReceivedString;\nconst MULTILINE_REGEXP = /\\n/;\nexports.MULTILINE_REGEXP = MULTILINE_REGEXP;\nconst NEWLINE_SYMBOL = '\\u{21B5}'; // downwards arrow with corner leftwards\n\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of the line.\n\nconst replaceSpacesAtEnd = line => line.replace(/\\s+$/, spaces => SPACE_SYMBOL.repeat(spaces.length));\nconst printDeleteLine = line => EXPECTED_COLOR(line.length !== 0 ? '- ' + replaceSpacesAtEnd(line) : '-');\nexports.printDeleteLine = printDeleteLine;\nconst printInsertLine = line => RECEIVED_COLOR(line.length !== 0 ? '+ ' + replaceSpacesAtEnd(line) : '+'); // Prevent visually ambiguous empty line as the first or the last.\n\nexports.printInsertLine = printInsertLine;\nconst printCommonLine = function (line) {\n  let isFirstOrLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return line.length !== 0 ? DIM_COLOR('  ' + replaceSpacesAtEnd(line)) : isFirstOrLast ? DIM_COLOR('  ' + NEWLINE_SYMBOL) : '';\n};\nexports.printCommonLine = printCommonLine;\nconst computeStringDiffs = (expected, received) => {\n  const isMultiline = MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n  if (isMultiline) {\n    expected += '\\n';\n    received += '\\n';\n  }\n  const diffs = (0, _diffStrings.default)(expected, received);\n  (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n\n  return {\n    diffs,\n    isMultiline\n  };\n};\nexports.computeStringDiffs = computeStringDiffs;\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\nexports.hasCommonDiff = hasCommonDiff;\nconst printAnnotation = options => EXPECTED_COLOR('- ' + (options && options.aAnnotation || 'Expected')) + '\\n' + RECEIVED_COLOR('+ ' + (options && options.bAnnotation || 'Received')) + '\\n\\n'; // In GNU diff format, indexes are one-based instead of zero-based.\n\nexports.printAnnotation = printAnnotation;\nconst createPatchMark = (aStart, aEnd, bStart, bEnd) => PATCH_COLOR(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`); // Return formatted diff lines without labels.\n\nexports.createPatchMark = createPatchMark;\nconst printMultilineStringDiffs = (diffs, expand) => {\n  const lines = (0, _getAlignedDiffs.default)(diffs);\n  return expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(lines) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(lines);\n};\nexports.printMultilineStringDiffs = printMultilineStringDiffs;\nconst MAX_DIFF_STRING_LENGTH = 20000;\n\n// Print specific substring diff for strings only:\n// * if strings are not equal\n// * if neither string is empty\n// * if neither string is too long\n// * if there is a common string after semantic cleanup\nconst getStringDiff = (expected, received, options) => {\n  if (expected === received || expected.length === 0 || received.length === 0 || expected.length > MAX_DIFF_STRING_LENGTH || received.length > MAX_DIFF_STRING_LENGTH) {\n    return null;\n  }\n  const _computeStringDiffs = computeStringDiffs(expected, received),\n    diffs = _computeStringDiffs.diffs,\n    isMultiline = _computeStringDiffs.isMultiline;\n  if (!hasCommonDiff(diffs, isMultiline)) {\n    return null;\n  }\n  return isMultiline ? {\n    annotatedDiff: printAnnotation(options) + printMultilineStringDiffs(diffs, options === undefined || options.expand !== false),\n    isMultiline\n  } : {\n    a: getExpectedString(diffs),\n    b: getReceivedString(diffs),\n    isMultiline\n  };\n};\nexports.getStringDiff = getStringDiff;","map":{"version":3,"names":["Object","defineProperty","exports","value","getStringDiff","printMultilineStringDiffs","createPatchMark","printAnnotation","hasCommonDiff","computeStringDiffs","printCommonLine","printInsertLine","printDeleteLine","MULTILINE_REGEXP","getReceivedString","getExpectedString","getHighlightedString","RECEIVED_COLOR","INVERTED_COLOR","EXPECTED_COLOR","DIM_COLOR","_chalk","_interopRequireDefault","require","_cleanupSemantic","_diffStrings","_getAlignedDiffs","_joinAlignedDiffs","obj","__esModule","default","dim","green","inverse","red","PATCH_COLOR","yellow","op","diffs","reduce","reduced","diff","DIFF_EQUAL","DIFF_DELETE","DIFF_INSERT","NEWLINE_SYMBOL","SPACE_SYMBOL","replaceSpacesAtEnd","line","replace","spaces","repeat","length","isFirstOrLast","expected","received","isMultiline","test","cleanupSemantic","iLast","some","i","options","aAnnotation","bAnnotation","aStart","aEnd","bStart","bEnd","expand","lines","joinAlignedDiffsExpand","joinAlignedDiffsNoExpand","MAX_DIFF_STRING_LENGTH","_computeStringDiffs","annotatedDiff","undefined","a","b"],"sources":["/home/laxus/Uchiha/[GigaCourse.Com] Udemy - React - The Complete Guide (incl Hooks, React Router, Redux)/08 - Time to Practice_ A Complete Practice Project/01-starting-project/node_modules/jest-diff/build/printDiffs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getStringDiff = exports.printMultilineStringDiffs = exports.createPatchMark = exports.printAnnotation = exports.hasCommonDiff = exports.computeStringDiffs = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = exports.MULTILINE_REGEXP = exports.getReceivedString = exports.getExpectedString = exports.getHighlightedString = exports.RECEIVED_COLOR = exports.INVERTED_COLOR = exports.EXPECTED_COLOR = exports.DIM_COLOR = void 0;\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst DIM_COLOR = _chalk.default.dim;\nexports.DIM_COLOR = DIM_COLOR;\nconst EXPECTED_COLOR = _chalk.default.green;\nexports.EXPECTED_COLOR = EXPECTED_COLOR;\nconst INVERTED_COLOR = _chalk.default.inverse;\nexports.INVERTED_COLOR = INVERTED_COLOR;\nconst RECEIVED_COLOR = _chalk.default.red;\nexports.RECEIVED_COLOR = RECEIVED_COLOR;\nconst PATCH_COLOR = _chalk.default.yellow; // Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op (inverse highlight)\n// * exclude change strings which have opposite op\n\nconst getHighlightedString = (op, diffs) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op\n        ? INVERTED_COLOR(diff[1])\n        : ''),\n    ''\n  );\n\nexports.getHighlightedString = getHighlightedString;\n\nconst getExpectedString = diffs =>\n  getHighlightedString(_cleanupSemantic.DIFF_DELETE, diffs);\n\nexports.getExpectedString = getExpectedString;\n\nconst getReceivedString = diffs =>\n  getHighlightedString(_cleanupSemantic.DIFF_INSERT, diffs);\n\nexports.getReceivedString = getReceivedString;\nconst MULTILINE_REGEXP = /\\n/;\nexports.MULTILINE_REGEXP = MULTILINE_REGEXP;\nconst NEWLINE_SYMBOL = '\\u{21B5}'; // downwards arrow with corner leftwards\n\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of the line.\n\nconst replaceSpacesAtEnd = line =>\n  line.replace(/\\s+$/, spaces => SPACE_SYMBOL.repeat(spaces.length));\n\nconst printDeleteLine = line =>\n  EXPECTED_COLOR(line.length !== 0 ? '- ' + replaceSpacesAtEnd(line) : '-');\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = line =>\n  RECEIVED_COLOR(line.length !== 0 ? '+ ' + replaceSpacesAtEnd(line) : '+'); // Prevent visually ambiguous empty line as the first or the last.\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast = false) =>\n  line.length !== 0\n    ? DIM_COLOR('  ' + replaceSpacesAtEnd(line))\n    : isFirstOrLast\n    ? DIM_COLOR('  ' + NEWLINE_SYMBOL)\n    : '';\n\nexports.printCommonLine = printCommonLine;\n\nconst computeStringDiffs = (expected, received) => {\n  const isMultiline =\n    MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n  if (isMultiline) {\n    expected += '\\n';\n    received += '\\n';\n  }\n\n  const diffs = (0, _diffStrings.default)(expected, received);\n  (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n\n  return {\n    diffs,\n    isMultiline\n  };\n};\n\nexports.computeStringDiffs = computeStringDiffs;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst printAnnotation = options =>\n  EXPECTED_COLOR('- ' + ((options && options.aAnnotation) || 'Expected')) +\n  '\\n' +\n  RECEIVED_COLOR('+ ' + ((options && options.bAnnotation) || 'Received')) +\n  '\\n\\n'; // In GNU diff format, indexes are one-based instead of zero-based.\n\nexports.printAnnotation = printAnnotation;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd) =>\n  PATCH_COLOR(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // Return formatted diff lines without labels.\n\nexports.createPatchMark = createPatchMark;\n\nconst printMultilineStringDiffs = (diffs, expand) => {\n  const lines = (0, _getAlignedDiffs.default)(diffs);\n  return expand\n    ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(lines)\n    : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(lines);\n};\n\nexports.printMultilineStringDiffs = printMultilineStringDiffs;\nconst MAX_DIFF_STRING_LENGTH = 20000;\n\n// Print specific substring diff for strings only:\n// * if strings are not equal\n// * if neither string is empty\n// * if neither string is too long\n// * if there is a common string after semantic cleanup\nconst getStringDiff = (expected, received, options) => {\n  if (\n    expected === received ||\n    expected.length === 0 ||\n    received.length === 0 ||\n    expected.length > MAX_DIFF_STRING_LENGTH ||\n    received.length > MAX_DIFF_STRING_LENGTH\n  ) {\n    return null;\n  }\n\n  const _computeStringDiffs = computeStringDiffs(expected, received),\n    diffs = _computeStringDiffs.diffs,\n    isMultiline = _computeStringDiffs.isMultiline;\n\n  if (!hasCommonDiff(diffs, isMultiline)) {\n    return null;\n  }\n\n  return isMultiline\n    ? {\n        annotatedDiff:\n          printAnnotation(options) +\n          printMultilineStringDiffs(\n            diffs,\n            options === undefined || options.expand !== false\n          ),\n        isMultiline\n      }\n    : {\n        a: getExpectedString(diffs),\n        b: getReceivedString(diffs),\n        isMultiline\n      };\n};\n\nexports.getStringDiff = getStringDiff;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}